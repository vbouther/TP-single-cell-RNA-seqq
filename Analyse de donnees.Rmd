---
title: "QC cell"
output: html_document
---

```{r}
# Seurat v3.0.0 and tximport >=1.13.10
library(Seurat)
library(tximport)

# path to the output directory of Alevin run of pbmc_1k 10x V2 data
alvquant <- file.path("/home/rstudio/disk/data/genome/alevin_output/alevin/quants_mat.gz")
file.exists(alvquant)
# Reading in the alevin quants quants
txi <- tximport(alvquant, type="alevin")
```
Controle qualité
On va compter le nombre d'UMI par cellule pour caractériser la qualité des cellules. Par exemple une cellule aec deux UMI sera éliminée. 
On compte aussi le nombre de gène exprimés par cellule. 
Récuperer les gènes mitochondriaux pour voir s'il ne sont pas surexprimés (apoptotiques)
```{r}
countUMIcell <- apply(txi$counts, 2, sum)
countgenescell <- colSums(txi$counts !=0)
hist(x = countUMIcell, breaks = 1000, xlim=range(0,10000))
hist(x = countgenescell, breaks = 1000, xlim=range(0,10000))
```

#names(txi)  "abundance"           "counts"              "length"              "countsFromAbundance"
#txi$counts[1:5,1:5]
 TGGACGCCATATGGTC CTACATTAGACTACAA ACGGCCATCGGTTCGG GGTATTGAGGTGCAAC CAGGTGCTCGGAGCAA
Xkr4                  0                0                0                0                0
Rp1                   0                0                0                0                0
Sox17                 0                0                0                0                0
Mrpl15                5                2                7                2                0
Lypla1                0                2                0                1                0

Recherche des gènes mitochondriaux: Pour trouver la liste: ensembl => 
```{r}
listgenes <- txi$counts[,0]
for (x in listgenes){
  i <- grep("mt",x)
  print(i)
}

```
solution
```{r}
listgenes<-rownames(listgenes)
g<-grep('mt-', listgenes) #renvoie la position
listgenesmt<-listgenes[g]
listgenesmt
```
On crée la matrice des genes mitochondriaux et les sommes de gènes pour avoir les histogrammes
```{r}
counts_mito <- txi$counts[listgenesmt,]
UMImito <- apply(counts_mito, 2, sum)
hist(x = UMImito, breaks = 1000)
```
Il faut décider d'un seuil au desssus duquel on élimine la cellule car elle exprime trop les gènes mitochondriaux et elle est donc morte. 


SEURAT
Seurat redonne les opérations précédentes
Seurat allows you to easily explore QC metrics and filter cells based on any user-defined criteria. A few QC metrics commonly used by the community include

The number of unique genes detected in each cell.
Low-quality cells or empty droplets will often have very few genes
Cell doublets or multiplets may exhibit an aberrantly high gene count
Similarly, the total number of molecules detected within a cell (correlates strongly with unique genes)
The percentage of reads that map to the mitochondrial genome
Low-quality / dying cells often exhibit extensive mitochondrial contamination
We calculate mitochondrial QC metrics with the PercentageFeatureSet function, which calculates the percentage of counts originating from a set of features
We use the set of all genes starting with mt- as a set of mitochondrial genes
```{r}
library(dplyr)
library(Seurat)
seuratobj <- CreateSeuratObject(counts = txi$counts, project = "seuratTPscRNAseq", min.cells = 3, min.features = 200)
seuratobj
```
```{r}
# The [[ operator can add columns to object metadata. This is a great place to stash QC stats
seuratobj[["percent.mt"]] <- PercentageFeatureSet(seuratobj, pattern = "^mt-")
summary(seuratobj[["percent.mt"]])
```
On a une cellule avec 66% de gènes mitochondriaux !


```{r}
# Visualize QC metrics as a violin plot
VlnPlot(seuratobj, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
```

We filter cells that have unique feature counts over 2,500 or less than 200
We filter cells that have >5% mitochondrial counts